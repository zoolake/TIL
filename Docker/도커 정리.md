> _인프런 ‘따라하며 배우는 도커와 CI 환경’ 를 보고 정리한 내용입니다._

# 목차

- [도커란?](#도커란?)
- [도커를 쓰는 이유?](#도커를-쓰는-이유?)
- [도커의 사용 흐름](#도커의-사용-흐름)
- [도커와 기존 가상화 기술과의 차이](#도커와-기존-가상화-기술과의-차이)
- [이미지 내부 파일 시스템 구조 보기](#이미지-내부-파일-시스템-구조-보기)
- [현재 실행중인 컨테이너 나열](#현재-실행중인-컨테이너-나열)
- [도커의 생명 주기](#도커의-생명-주기)

# 도커란?

- **컨테이너**를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며
  컨테이너 기반의 오픈소스 가상화 플랫폼이며 생태계이다.
- **다양한 프로그램, 실행환경을 컨테이너로 추상화**하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해준다.

## 컨테이너

- 코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 안정적이고 빠르게 실행되도록 하는 소프트웨어 표준 단위이다.

## 컨테이너 이미지

<aside>
📍 이미지를 이용해서 컨테이너를 생성하며, 컨테이너를 이용해서 프로그램을 실행한다.

</aside>

- 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는 데 필요한 모든 것을 포함한 가볍고 독립적이며 실행 가능한 소트프웨어 패키지

### 이미지를 통해 컨테이너 만드는 과정

1. Docker 클라이언트에 `docker run <이미지>` 입력
2. 이미지에 있는 파일 스냅샷을 컨테이너 하드 디스크에 옮김
3. 이미지에 있는 명령어 (컨테이너가 실행될 때 사용될 명령어)를 이용해서 어플리케이션을 실행

# 도커를 쓰는 이유?

- 서버, 패키지 버전, 운영체제 등에 따라서 프로그램 설치를 위해 고려해야 할 부분이 많다.
- 프로그램을 다운 받는 과정을 간단하게 만들기 위해서 도커를 사용한다.

# 도커의 사용 흐름

**도커의 실행 흐름은 다음과 같다.**

1. 도커 CLI에 명령어 입력
2. 도커 서버 (도커 Daemon)이 명령어를 받고 그것에 따라 이미지를 생성하든 컨테이너를 실행하든 작업을 수행한다.

`**dockr run hello-world` 를 입력하면 다음과 같이 실행된다.\*\*

1. `dockr run hello-world` 를 입력한다.
2. 도커 서버에서 위 명령어가 전해진다.
3. hello-world 라는 이미지가 로컬 이미지 캐시에 저장되어 있는지 확인한다.
   1. 만약 이미지가 없다면 도커 허브에서 이미지를 가져온다.

# 도커와 기존 가상화 기술과의 차이

## 배경

### 가상화 기술 나오기 전

- 하나의 서버에 하나의 운영체제, 하나의 프로그램만을 운영
- 안정적이나 매우 비효율적

### 하이퍼 바이저 기반의 가상화 출현

- **하이퍼 바이저**는
  - 호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어
  - 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링 하는 중간 관리자
- 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용 가능

## 하이퍼 바이저 기반의 VM 구조

- 각 VM마다 독립된 가상 하드웨어 자원을 할당받는다.
- 논리적으로 분리되어 있기 때문에 하나의 VM에서 오류가 발생해도 다른 VM으로 퍼지지 않는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d349d3a7-0a8b-42b3-893e-77a0509403ff/Untitled.png)

## 컨테이너 가상화 기술의 등장

기존 가상화 기술과의 공통점과 차이점을 먼저 알아보면 다음과 같다.

- 공통점
  - 기본 하드웨어에서 격리된 환경 내에 애플리케이션을 배치
- 차이점
  - 컨테이너는 하이퍼바이저와 게스트 OS가 필요없기 때문에 가볍다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df9fce7d-f2fb-4c9d-92bf-e241a7cc9694/Untitled.png)

## 도커 컨테이너의 격리

리눅스 커널 기능들 중 **Cgroups(control groups)**와 **네임스페이스**를 통해 컨테이너와 호스트에서 실행되는 다른 프로세스 사이엑 벽을 만든다.

### Cgroups

- CPU, 메모리, Network Bandwith 등 프로세스 그룹의 시스템 리소스 사용량을 관리
- 특정 어플리케이션이 사용량이 너무 많다면 Cgroups에 넣어서 CPU와 메모리 사용 제한

### 네임스페이스

- 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
- 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술

# 이미지 내부 파일 시스템 구조 보기

이미지 내부 파일 시스템 구조를 보기 위해서는 `docker run <이미지> ls` 를 사용하며 뜯어보면 다음과 같다.

- docker → 도커 클라이언트 언급
- run → 컨테이너 생성 및 실행
- 이미지 → 컨테이너를 위한 이미지
- ls
  - ls 커맨드는 현재 디렉토리의 파일 리스트를 나타내기 위해 사용된다.
  - 위 예시에서 ls 명령어가 작성된 위치는 **원래 이미지가 가지고 있는 시작 명령어를 무시**하고 해당 위치의 커맨드를 실행하게 한다.

# 현재 실행중인 컨테이너 나열

`docker ps` 명령어를 통해서 현재 실행중인 컨테이너들을 확인할 수 있다.
만약, 실행중이지 않은 컨테이너들도 보고싶다면 -a 옵션을 준다.

- ps는 process status 를 의미
- `docker ps -a`

그리고 다음과 같은 속성들을 볼 수 있다.

- CONTAINER ID
  - 컨테이너의 고유한 아이디 해쉬값
  - 실제는 더 길지만 일부만 보임
- IMAGE
  - 컨테이너 생성시 사용한 도커 이미지
- COMMAND
  - 컨테이너 시작시 실행될 명령어
  - 대부분 이미지에 내장되어 있으므로 별도 설정이 필요없다
  - 만약, `docker run <이미지> ping localhost` 를 입력하면 COMMAND 는 `ping localhost`가 나온다.
- CREATED
  - 컨테이너가 생성된 시간
- STATUS
  - 컨테이너의 상태
    - Up : 실행중
    - Exited : 종료
    - Pause : 일시정지
- PORTS
  - 컨테이너가 개방한 포트와 호스트에 연결한 포트
  - 특별한 설정을 하지 않은 경우 출력되지 않는다.
- NAMES
  - 컨테이너 고유한 이름
  - 컨테이너 생성시 `--name` 옵션으로 이름을 설정할 수 있다.
  - 별도의 이름 설정이 없다면 도커 엔진이 임의로 설정한다.
  - id와 동일하게 중복은 불가능하다
  - `docker rename original-name changed-name` 을 통해 이름을 변경할 수 있다.

# 도커의 생명주기

## run = create + start

`docker run <이미지>` 는 `docker create <이미지>` 와 `docker start <시작할 컨테이너 아이디/이름>` 으로 나눌 수 있다.

### docker create <이미지>

이미지 내의 파일 스냅샷을 생성된 컨테이너의 하드 디스크에 넣어준다.

### docker start <컨테이너 아이디/이름>

컨테이너 아이디에 해당하는 컨테이너에 접근하여 이미지 내의 명령어를 컨테이너에 넣어준다.

```
>>> docker create hello-world
1294022d5c31b0f89fcae4850b0397de7c6d3af9dcdb147cf6448ee3e6df159b

>>> docker start -a 1294022
Hello from Docker!
This message shows that your installation appears to be working correctly.
```

docker start 시 -a 옵션의 역할은 도커 컨테이너가 실행이 될 때 그쪽에 붙어있다가 거기서 나오는 아웃풋을 화면에 출력해주는 역할을 한다. (-a == attach)
